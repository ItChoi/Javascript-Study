### 인사이드 자바스크립트 4장 - 함수와 프로토타입 체이닝
	- JS에서 가장 중요한 개념 1순위는 함수다.
	- JS에서는 일반 함수적 기능 외에도 모듈화 처리나 클로저, 객체 생성 등 JS의 근간이 되는 많은 기능을 제공한다.

##### 4.1 함수 정의
	- JS에서 함수를 생성하는 방법은 3가지가 있다. 각 방식에 따라 함수 동작이 미묘하게 차이가 난다.
		1. 함수 선언문(function statement)
		2. 함수 표현식(function expression)
		3. Function() 생성자 함수
    
    - 함수 리터럴을 통한 add() 함수 정의
    ex)
		function add(x, y) {
			return x + y;
		}
		
		- 함수명은 함수 몸체 내부에서 자신을 재귀적으로 호출하거나 또는 JS 디버거가 해당 함수를 구분하는 식별자로 사용된다. 함수명은 선태 사항이다.
		
##### 함수 선언문 방식으로 함수 생성하기.		
	- 함수 리터럴 형태와 같고, 반드시 함수명이 정의되어 있어야 한다.
	ex)
		function add(x, y) {
			return x + y;
		}
		console.log(add(3, 4));
		
##### 4.1.3 함수 표현식 방식으로 함수 생성하기.	
	- JS에서는 함수도 하나의 값으로 취급된다. 이러한 특징으로 JS는 함수를 일급 객체라고 한다. 따라서 함수도 숫자나 문자열처럼 변수에 할당 가능하다.

##### 함수 표현식으로 함수 생성하기.
	- 익명 함수를 add 변수에 넣어줬다. 
	- 함수명은 선택 사항.
	ex)
		var add = function(x, y) {
			return x + y;
		};		
		var plus = add;
		console.log(add(3, 4)); // 출력값: 7
		console.log(add(5, 6)); // 출력값: 11
		
		// add 함수 변수  ->
		// 				(익명함수)
		// plus 함수 변수 ->
		
	- 함수 선언문으로 정의한 함수는 JS 엔진에 의해 함수 표현식 형태로 변경된다.
	ex) 
		function add() { } -> var add = function add() { }
		
	- 함수 표현식에서 내부 함수를 이용하면 재귀적인 호출 처리도 가능하다. ex) factorial
	
	- 함수 선언문은 함수 끝에 세미콜론을 붙이지 않지만, 함수 표현식은 끝에 세미콜론을 붙이는 것을 권장한다. JS의 하나의 관습이다.
	- JS는 세미콜론을 강제하지 않는데, 이는 JS 인터프리터가 자동으로 세미콜론을 삽입시켜 주기 때문이다. 
	그러나 세미콜론을 신경쓰지 않으면, 심각한 디버깅 상황을 맞이할 수 있다.
	ex)
		var func = function() {
			return 42;
		}	// 세미콜론을 사용하지 않음.
		(function() {
			console.log("function called");
		})();
	해설)
		- func을 닫는 중괄호( } )에 세미콜론을 붙이지 않아 JS parser가 함수가 끝났다고 판단하지 않고, 이후에 정의된 즉시 실행 함수를
		보고 이를 마치 func() 함수 호출 연산으로 생각해서 func() 함수를 호출하고, return된 42를 가지고 42();를 호출하게 되서,
		'number is not a function' 에러가 발생하게 된다.
		 이런 문제가 발생할 수 있어 JS 가이드에서는 함수 표현식 방식에서의 세미콜론 사용을 강력하게 권고하고 있다.
		 	
##### 4.1.4 Function() 생성자 함수를 통한 함수 생성하기.
	- JS 함수는 Function() 이라는 기본 내장 생성자 함수로부터 생성된 객체라고 볼 수 있다.
	- 함수 선언문, 함수 표현식 방식도 결국엔 내부적으로 Function() 생성자 함수로 생성된다.
	ex)
		var add = new Function('x', 'y', 'return x + y');
		console.log(add(3, 4)); // 출력값: 7
	- 일반적으로 많이 사용되지 않으며, 인사이드 자바스크립트에서는 더이상 다루지 않는다.
	
##### 4.1.5 함수 호이스팅
	- 함수 선언문, 함수 표현식, 생성자 함수를 통해 함수를 생성할 때, 동작 방식의 차이가 있는데,
	그 중 하나가 바로 함수 호이스팅(Function Hoisting)이다.
	
	- JS 고수 더글러스 크락포드는 함수 생성에 있어서 함수 표현식만을 사용할 것을 권하고 있다.
	 
	ex)
		add(2, 3);	// 정상 작동
		function add(x, y) { return x + y; }
		add(3, 4); // 정상 작동
	해설)
		함수 정의 전에 함수를 호출해도 정상 작동한다. 왜냐하면 함수 선언문으로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다.
		이를 함수 호이스팅이라 부른다.
		 따라서 JS 고수는 함수 호이스팅은 함수 호출 전 반드시 선언해야 한다는 규칙을 무시하므로 코드의 규칙을 무시하고 있다고 지적했다. 그러쿤.. 
	
	ex)
		add(2, 3); // uncaught type error
		var add = function(x, y) { return x + y; }
		add(3, 4); // 정상 작동
		
	- 이러한 함수 호이스팅이 발생하는 원인은 JS의 변수 생성(Instantiation)과 초기화(Initialization)의 작업이 분리되어 진행되기 때문이다. (5장에서 다룸)
	
##### 4.2 함수 객체: 함수도 객체다
	- 함수를 생성할 때 함수 코드는 함수 객체의 [[Code]] 내부 프로퍼티에 자동으로 저장된다. (ECMAScript 명세서 참조)
	ex)
		function add(x, y) {
			return x + y;
		}
		add.result = add(3, 2);
		add.status = 'OK';
	프로퍼티)
		[[Code]] -----> return x + y;
		result -------> 5
		status -------> 'OK'
		
##### 4.2.2 JS에서 함수는 값으로취급된다.
	- 함수는 객체다. 이는 함수도 일반 객체처럼 취급될 수 있다는 것을 말한다.
	- JS 함수는 다음과 같은 동작이 가능하다. (나열한 것 모두 가능하면 일급 객체)
		1. 리터럴에 의해 생성
		2. 변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능
		3. 함수의 인자로 전달 가능
		4. 함수의 리턴 값으로 리턴 가능
		5. 동적으로 프로퍼티를 생성 및 할당 가능
	
##### 4.2.2.1 변수나 프로퍼티의 값으로 할당
	- 함수는 숫자나 문자열처럼 변수나 프로퍼티의 값으로 할당될 수 있다.
	ex)
		var bar = function() { }
		var obj = {};
		obj.baz = function () { }
		
##### 4.2.2.2 함수 인자로 전달
	- 함수는 다른 함수의 인자로 전달 가능하다.
	ex)
		var foo = function(func) { 
			func(); 
		};
		foo(function() { console.log('바보'); });
				
##### 4.2.2.3 리턴 값으로 활용
	- 함수는 다른 함수의 리턴 값으로도 활용할 수 있다.
	ex)
		var foo = function() {
			return function() { console.log('바보') };
		};	
		
##### 4.2.3 함수 객체의 기본 프로퍼티
	- 일반 객체와는 다르게 추가로 함수 객체만의 표준 프로퍼티가 정의되어 있다.
	ex)
		function add(x, y) { return x + y; }
		console.dir(add);	
	해설)
		- ECMA5 스크립트 명세서에는 모든 함수가 length와 prototype 프로퍼티를 가져야 한다고 기술하고 있다.
		- 그 외에 name, caller, arguments, __proto__ 프로퍼티를 간단히 살펴 보자. 이들 프로퍼티는 ECMA 표준이 아니다.
			1. name: 함수의 이름을 나타내며, 익명 함수라면 빈 문자열을 나타낸다.
			2. caller: 자신을 호출한 함수를 나타낸다. 호출한 함수가 없으면 null
			3. arguments: 함수 호출 시 전달된 인자 값
			4. __proto__: 
				- 모든 JS 객체는 자신의 프로토타입을 가리키는 [[Prototype]]라는 내부 프로퍼티를 가진다.
				- 크롬 브라우저는 [[Prototype]]이라는 내부 프로퍼티가 바로 __proto__ 프로퍼티로 구현되어 있다. 즉 같은 개념이다.
				- 함수 객체의 부모 역할을 하는 프로토 타입 객체를 Function.prototype 객체라고 명명하고 있으며 함구 객체라고 정의하고 있다.
				- Function.prototype 객체는 모든 함수들의 부모 역할을 하는 프로토타입 객체다.
			5. length: ECMAScript에서 정한 모든 함수가 가져야 하는 표준 프로퍼티로서 인자의 개수를 나타낸다.
			
##### 4.2.3.2 prototype 프로퍼티
	- prototype: 
		- 모든 함수는 객체로서 prototype을 가지고 있다.
		- 함수 객체의 prototype은 모든 객체의 부모를 나타내는 내부 프로퍼티인 [[Prototype]]과 혼동하지 말아야 한다.
		
	- prototype 프로퍼티와 [[Prototype]] 프로퍼티
		- 두 프로퍼티 모두 프로토타입 객체를 가리킨다는 공통점이 있다.
		- [[Prototype]]
			- 모든 객체에 있는 내부 프로퍼티
			- 객체 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리킨다.
		- prototype
			- 함수가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 포로타타입 객체를 가리킨다.
		- 4.5.1 프로토타입의 두가지 의미에서 자세히 살펴 볼 것임.
		
	- prototype은 함수가 생성될 때 만들어지고 constructor 프로퍼티 하나만 있는 객체를 가리킨다.
	그리고 constructor는 자신과 연결된 함수를 가리킨다. 즉 JS에서는 함수를 생성할 때 함수 자신과 연결된 프로토타입 객체를 
	동시에 생성하며, 이 둘은 각각 prototype과 constructor로 서로를 참조하게 된다.
	
	- 함수의 프로토 타입 객체
	ex)
		function myFunction() { // (1)
			return true;
		}
		console.dir(myFunction.prototype); // (2)
		console.dir(myFunction.prototype.constructor); // (3)
	해설)
		(1)에서 함수가 생성됨과 동시에 myFunction() 함수의 prototype에는 이 함수와 연결된 프로토타입 객체가 생성된다.
		(2)에서 myFunction.prototype객체는 constructor와 __proto__ 라는 두 개의 프로퍼티가 있다.
		(3)을 출력함으로써 프로토타입 객체와 매핑된 함수를 알아볼 수 있다.
		따라서 함수 객체와 프로토타입 객체는 서로 밀접하게 연결돼 있다.
		
##### 4.3 함수의 다양한 형태

##### 4.3.1 콜백 함수
	- 익명 함수의 대표적인 용도가 바로 콜백 함수이다.
	- 콜백 함수는 코드를 통해 명시적으로 호출하는 함수가 아니라, 개발자는 단지 함수를 등록하기만 하고, 
	이벤트가 발생하거나 특정 시점에 도달했을 때 시스템에서 호출되는 함수를 말한다.
	- 또한 특정 함수의 인자로 넘겨서, 코드 내부에서 호출되는 함수 또한 콜백 함수가 될 수 있다.
	- 대표적인 콜백 함수의 사용 예가 JS에서의 이벤트 핸들러 처리이다. (페이지 로드, 키보드 입력 등) - 브라우저는 정의된 DOM 이벤트에 해당하는 핸들러를 실행
	ex) 
		1. 개발자 -> 콜백 함수 등록
		2. 이벤트 발생 -> 이벤트 핸들러 -> 콜백 함수 호출
	ex)
		<script>
			window.onload = function() {
				alert("메시지");
			}
		</script>
	
##### 4.3.2 즉시 실행 함수
	- 함수를 정의함과 동시에 바로 실행하는 함수를 즉시 실행 함수라고 한다.
	ex)
		(function(name) {
			console.log(name + '은 바보다.');
		})('foo');
	- 즉시 실행 함수 실행 방법
		1. 함수c 리터럴을 ()로 감싼다.
		2. 함수가 바로 실행 가능하게 ()를 추가하고, 괄호 안에 인자를 넣어줄 수 있다.
	- 함수가 선언되자마자 실행되게 만들어 다시 호출할 수 없다. 이러한 특징을 이용해 최초 한 번의 실행을 필요로 하는 초기화 코드
	- 최싱 jQuery 소스를 확인하면 소스 코드 전체가 즉시 실행 함수로 감싸져 있다. 이렇게 즉시 실행 함수를 사용하는 이유는
	JS의 변수 유효 범위 특성 때문이다. JS는 함수 유효 범위를 지원한다. 기본적으로 JS는 변수를 선언할 경우 프로그램 전체에서 
	접근할 수 있는 전역 유효 범위를 가지게 된다. 그러나 함수 내부에서 정의된 매개변수와 변수들은 함수 코드 내부에서만 유효하다.
	여기서 변수들은 var문을 사용해서 정의해야 한다. 그렇지 않으면 함수 내의 변수라도 전역 유효 범위를 갖게 된다.
	
##### 4.3.3 내부 함수
	- 함수 내부에 정의된 함수를 내부 함수라고 한다. 이는 클로저를 생성하거나 부모 함수 코드에서 외부의 접근을 막고 독립적인 헬퍼 함수를 구현하는 용도 등으로 사용된다.
	ex)
		function parent() {
			var a = 100;
			var b = 200;
			
			function child() {
				var b = 300;
				
				console.log(a);
				console.log(b);
			}
			child();
		}	
		parent(); // a = 100, b = 300
		child(); // uncaught RefereneError 발생
	해설)
		child 내부 하무는 부모에서 정의된 변수를 사용할 수 있다. b 같은 경우 child에 정의된 변수를 사용하게 된다.
		이것이 가능한 이유는 JS의 스코프 체이닝 때문이다. (5장에서 자세히 살펴봄)
		- 함수 스코핑: 함수 내부에 선언된 변수는 함수 외부에서 접근이 불가능하다.
		- 부모 함수에서 내부 함수를 외부로 리턴하면 부모 함수 밖에서도 내부 함수를 호출하는 것이 가능하다.
		ex)
			function parent() {
				var a = 100;
				var child = function() {
					console.log(a);
				}
				return child;
			}	
			var inner = parent();
			inner();
		해설)
			이와 같이 실행이 끝난 parent() 함수 스코프의 변수를  참조하는 inner()와 같은 함수를 클로저라고 한다.

##### 4.3.4 함수를 리턴하는 함수
	ex)
		var self = function() {
			console.log('a');
			return function() {
				console.log('b');
			}
		}
		self = self();
		self();
	해설)
		변수 self에 self()함수를 넣을 때 a 메시지가 찍히고, 리턴된 값이 self에 담긴다 그리고 self()호출 시 b만 찍힌다.
			
##### 4.4 함수 호출과 this
	
##### 4.4.1 arguments 객체
	- JS는 함수 호출 시 함수 인자 개수에 맞게 인자를 넘기지 않더라구 에러가 발생하지 않는다. 덜 넣으면 undefined, 더 넣으면 무시
	- 이러한 특성 때문에 함수 코드 작성 시, 런타임 시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다륵 해줘야 할 경우가 있다.
	이를 가능하게 하는 것이 바로 arguments 객체다.
	- JS는 함수 호출 시 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달된다. arguments 객체는 함수를 호출할 때
	넘긴 인자들이 배열 형태로 저장된 객체를 의미한다. 이 객체는 실제 배열이 아닌 유사 배열 객체다.
	ex)
		function add(a, b) {
			console.dir(arguments);
			return a + b;
		}
		console.dir(add);
		console.log(add(1)); // NaN
		console.log(add(1, 2)); // 3 
		console.log(add(1, 2, 3)); // 3
	해설)
		arguments 객체는 매개 변수 개수가 정확히 정해지지 않은 함수를 구현하거나, 전달된 인자의 개수에 따라 서로 다른 처리를 해야할 때 유용하다.
		
##### 4.4.2 호출 패턴과 this 바인딩
	- JS는 함수 호출 시 인자값과 arguments객체 및 this 인자가 함수 내부로 암묵적으로 전달된다.
	- this는 함수 호출 방식에 따라 this가 다른 객체를 참조한다. (this 바인딩)

##### 4.4.2.1 객체의 메서드 호출할 때 this 바인딩
	- 객체의 프로퍼티가 함수일 경우 이 함수를 메서드라 부른다. 메서드 내부 코드에서 사용된 this는 해당 메서드를 호출한 객체로 바인딩된다.
	- 밑에 예제에서는 this가 각각 myObject, otherObject가 된다. (객체 프로퍼티가 함수일 경우)
	ex)
		var myObject = {
			name: 'foo',
			sayName: function() {
				console.log(this.name);
			}
		};
		var otherObject = {
			name: 'bar'
		};
		otherObject.sayName = myObject.sayName;
		
		myObject.sayName();
		otherObject.sayName();

##### 4.4.2.2 함수를 호출할 때 this 바인딩
	- JS에서는 함수 호출 시 해당 함수 내부 코드에서 사용된 this는 전역 객체에 바인딩된다.
	브라우저에서 JS를 실행하는 경우 전역 객체는 window 객체가 된다.
	
	- 전역 객체란 무엇인가?? (브라우저, Node.js)
		- 브라우저 환경에서 JS 실행하는 경우 전역 객체는 window 객체가 된다.
		- Node.js와 같은 JS 언어를 통해 서버 프로그래밍을 할 수 있게끔 해주는 JS 런타임 환경에서의 전역 객체는 global 객체가 된다.
		Node.js는 JS 개발자에게 브라우저 기반의 프로그래밍을 넘어 서버 기반 프로그래밍 영역까지 개발을 가능하게끔 해주는 플랫폼이다.
		- JS의 모든 전역 변수는 실제로 이 전역 객체의 프로퍼티들이다.
		ex)
			var foo = "I'm foo";
			console.log(foo);
			console.log(window.foo);
			console.log(this.foo);
		
		ex)
			var test = 'This is test';
			console.log(window.test);
			var sayFoo = function() {
				console.log(this.test);
			}
			sayFoo();
	
		- 이러한 함수 호출에서의 this 바인딩 특성은 내부 함수를 호출했을 경우에도 그대로 적용되므로 내부 함수에서 this를 이용할 때 주의해야 한다.
		ex)
			var value = 100;
			
			var myObject = {
				value: 1,
				func1: function() {
					this.value += 1;
					console.log('func1() called. this.value : ' + this.value);
					func2 = function() {
						this.value += 1;
						console.log('func2() called. this.value : ' + this.value);
						
						func3 = function() {
							this.value += 1;
							console.log('func3() called. this.value : ' + this.value);
						}
						func3();
					}
					func2();
				}
			};
			myObject.func1();
		해설)
			1. func1에서 this.value += 1은 this가 myObject를 가르킨다. value: 2
			2. func2와 func3에서 this는 window를 가르키게 된다. value: 101, 102
			- this의 실행결과가 다르게 나온 것은, JS에서는 내부 함수 호출 패턴을 정의해 놓지 않기 때문이다.
			내부 함수도 결국 함수이므로 this는 전역 객체에 바인딩된다. 따라서 func2, func3에서 func1의
			this를 사용하고자 할 경우 다른 변수에 this를 담아서 사용해야 한다. var that = this;
			
			- JS에서는 이와 같은 this 바인딩의 한계를 극복하고 this 바인딩을 명시적으로 할 수 있도록 call과 apply 메서드를 제공한다.
			게다가 jQuery, underscore.js 등과 같은 JS 라이브러리들의 경우 bind 메서드를 통해 사용자가 원하는 this에 바인딩 할 수 있다.(7장에서 소개)
			
##### 4.4.2.3 생성자 함수를 호출할 때 this 바인딩
	- JS 객체를 생성하는 방법은 크게 객체 리터럴 방식과 생성자 함수를 이용하는 두 가지 방법이 있다.
	- JS에서 생성자 함수는 기존 함수에 new 연산자를 붙여 호출하면  생성자 함수로 동작하며 함수 이름의 첫 문자를 대문자로 쓰기를 권장하고 있다.
	- JS에서는 생성자 함수를 호출할 때, 생성자 함수 코드 내부에서 this를 이해하려면 생성자 함수 호출 시 동작 방식을 살펴봐야 한다.
		- 생성자 함수 동장 방식 (p 110 참조)
			1. 빈 객체 생성 및 this 바인딩
			2. this를 통한 프로퍼티 생성
			3. 생성된 객체 리턴
	ex) 
		var Person = function(name) {
			this.name = name;
		};
		var foo = new Person('foo');
		console.log(foo.name);
	해설)
		1. Person() 함수가 생성자로 호출되면 함수 코드가 실행되기 전 빈 객체가 생성된다.
		2. 빈 객체는 Person() 생성자 함수의 prototype 프로퍼티가 가르 키는 객체(Person.prototype객체)를 [[Prototype]]
		링크로 연결해서 자신의 프로토 타입을 설정한다.
		3. 생성된 객체는 생성자 함수 코드에서 사용되는 this로 바인딩된다. 
		4. this가 가리키는 빈 객체에 name이라는 동적 프로퍼티를 생성했다. 

	ex) 객체 생성 두 가지 방법(객체 리터럴, 생성자 함수)
		var foo = {
			name: 'foo',
			age: 35,
			gender: 'man'
		};			
		console.dir(foo);
		
		function Person(name, age, gender, position) {
			this.name = name;
			this.age = age;
			this.gender = gender;
		}
		var bar = new Person('bar', 33, 'woman');
		console.dir(bar);
		var baz = new Person('bar', 25, 'man');
		console.dir(baz);
		
		
		
			
			
			
			
	
		
	
	