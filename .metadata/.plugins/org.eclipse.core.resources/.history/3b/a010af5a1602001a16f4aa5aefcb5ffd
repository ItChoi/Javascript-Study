### 인사이드 자바스크립트 4장 - 함수와 프로토타입 체이닝
	- JS에서 가장 중요한 개념 1순위는 함수다.
	- JS에서는 일반 함수적 기능 외에도 모듈화 처리나 클로저, 객체 생성 등 JS의 근간이 되는 많은 기능을 제공한다.

##### 4.1 함수 정의
	- JS에서 함수를 생성하는 방법은 3가지가 있다. 각 방식에 따라 함수 동작이 미묘하게 차이가 난다.
		1. 함수 선언문(function statement)
		2. 함수 표현식(function expression)
		3. Function() 생성자 함수
    
    - 함수 리터럴을 통한 add() 함수 정의
    ex)
		function add(x, y) {
			return x + y;
		}
		
		- 함수명은 함수 몸체 내부에서 자신을 재귀적으로 호출하거나 또는 JS 디버거가 해당 함수를 구분하는 식별자로 사용된다. 함수명은 선태 사항이다.
		
##### 함수 선언문 방식으로 함수 생성하기.		
	- 함수 리터럴 형태와 같고, 반드시 함수명이 정의되어 있어야 한다.
	ex)
		function add(x, y) {
			return x + y;
		}
		console.log(add(3, 4));
		
##### 4.1.3 함수 표현식 방식으로 함수 생성하기.	
	- JS에서는 함수도 하나의 값으로 취급된다. 이러한 특징으로 JS는 함수를 일급 객체라고 한다. 따라서 함수도 숫자나 문자열처럼 변수에 할당 가능하다.

##### 함수 표현식으로 함수 생성하기.
	- 익명 함수를 add 변수에 넣어줬다. 
	- 함수명은 선택 사항.
	ex)
		var add = function(x, y) {
			return x + y;
		};		
		var plus = add;
		console.log(add(3, 4)); // 출력값: 7
		console.log(add(5, 6)); // 출력값: 11
		
		// add 함수 변수  ->
		// 				(익명함수)
		// plus 함수 변수 ->
		
	- 함수 선언문으로 정의한 함수는 JS 엔진에 의해 함수 표현식 형태로 변경된다.
	ex) 
		function add() { } -> var add = function add() { }
		
	- 함수 표현식에서 내부 함수를 이용하면 재귀적인 호출 처리도 가능하다. ex) factorial
	
	- 함수 선언문은 함수 끝에 세미콜론을 붙이지 않지만, 함수 표현식은 끝에 세미콜론을 붙이는 것을 권장한다. JS의 하나의 관습이다.
	- JS는 세미콜론을 강제하지 않는데, 이는 JS 인터프리터가 자동으로 세미콜론을 삽입시켜 주기 때문이다. 
	그러나 세미콜론을 신경쓰지 않으면, 심각한 디버깅 상황을 맞이할 수 있다.
	ex)
		var func = function() {
			return 42;
		}	// 세미콜론을 사용하지 않음.
		(function() {
			console.log("function called");
		})();
	해설)
		- func을 닫는 중괄호( } )에 세미콜론을 붙이지 않아 JS parser가 함수가 끝났다고 판단하지 않고, 이후에 정의된 즉시 실행 함수를
		보고 이를 마치 func() 함수 호출 연산으로 생각해서 func() 함수를 호출하고, return된 42를 가지고 42();를 호출하게 되서,
		'number is not a function' 에러가 발생하게 된다.
		 이런 문제가 발생할 수 있어 JS 가이드에서는 함수 표현식 방식에서의 세미콜론 사용을 강력하게 권고하고 있다.
		 	
##### 4.1.4 Function() 생성자 함수를 통한 함수 생성하기.
	- JS 함수는 Function() 이라는 기본 내장 생성자 함수로부터 생성된 객체라고 볼 수 있다.
	- 함수 선언문, 함수 표현식 방식도 결국엔 내부적으로 Function() 생성자 함수로 생성된다.
	ex)
		var add = new Function('x', 'y', 'return x + y');
		console.log(add(3, 4)); // 출력값: 7
	- 일반적으로 많이 사용되지 않으며, 인사이드 자바스크립트에서는 더이상 다루지 않는다.
	
##### 4.1.5 함수 호이스팅
	- 함수 선언문, 함수 표현식, 생성자 함수를 통해 함수를 생성할 때, 동작 방식의 차이가 있는데,
	그 중 하나가 바로 함수 호이스팅(Function Hoisting)이다.
	
	- JS 고수 더글러스 크락포드는 함수 생성에 있어서 함수 표현식만을 사용할 것을 권하고 있다.
	 
	ex)
		add(2, 3);	// 정상 작동
		function add(x, y) { return x + y; }
		add(3, 4); // 정상 작동
	해설)
		함수 정의 전에 함수를 호출해도 정상 작동한다. 왜냐하면 함수 선언문으로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다.
		이를 함수 호이스팅이라 부른다.
		 따라서 JS 고수는 함수 호이스팅은 함수 호출 전 반드시 선언해야 한다는 규칙을 무시하므로 코드의 규칙을 무시하고 있다고 지적했다. 그러쿤.. 
	
	ex)
		add(2, 3); // uncaught type error
		var add = function(x, y) { return x + y; }
		add(3, 4); // 정상 작동
		
	- 이러한 함수 호이스팅이 발생하는 원인은 JS의 변수 생성(Instantiation)과 초기화(Initialization)의 작업이 분리되어 진행되기 때문이다. (5장에서 다룸)
	
##### 4.2 함수 객체: 함수도 객체다
	- 함수를 생성할 때 함수 코드는 함수 객체의 [[Code]] 내부 프로퍼티에 자동으로 저장된다. (ECMAScript 명세서 참조)
	ex)
		function add(x, y) {
			return x + y;
		}
		add.result = add(3, 2);
		add.status = 'OK';
	프로퍼티)
		[[Code]] -----> return x + y;
		result -------> 5
		status -------> 'OK'
		
##### 4.2.2 JS에서 함수는 값으로취급된다.
	- 함수는 객체다. 이는 함수도 일반 객체처럼 취급될 수 있다는 것을 말한다.
	- JS 함수는 다음과 같은 동작이 가능하다. (나열한 것 모두 가능하면 일급 객체)
		1. 리터럴에 의해 생성
		2. 변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능
		3. 함수의 인자로 전달 가능
		4. 함수의 리턴 값으로 리턴 가능
		5. 동적으로 프로퍼티를 생성 및 할당 가능
	
##### 4.2.2.1 변수나 프로퍼티의 값으로 할당
	- 함수는 숫자나 문자열처럼 변수나 프로퍼티의 값으로 할당될 수 있다.
	ex)
		var bar = function() { }
		var obj = {};
		obj.baz = function () { }
		
##### 4.2.2.2 함수 인자로 전달
	- 함수는 다른 함수의 인자로 전달 가능하다.
	ex)
		var foo = function(func) { 
			func(); 
		};
		foo(function() { console.log('바보'); });
				
##### 4.2.2.3 리턴 값으로 활용
	- 함수는 다른 함수의 리턴 값으로도 활용할 수 있다.
	ex)
		var foo = function() {
			return function() { console.log('바보') };
		};	
		
##### 4.2.3 함수 객체의 기본 프로퍼티
	- 일반 객체와는 다르게 추가로 함수 객체만의 표준 프로퍼티가 정의되어 있다.
	ex)
		function add(x, y) { return x + y; }
		console.dir(add);	
	해설)
		- ECMA5 스크립트 명세서에는 모든 함수가 length와 prototype 프로퍼티를 가져야 한다고 기술하고 있다.
		- 그 외에 name, caller, arguments, __proto__ 프로퍼티를 간단히 살펴 보자. 이들 프로퍼티는 ECMA 표준이 아니다.
			1. name: 함수의 이름을 나타내며, 익명 함수라면 빈 문자열을 나타낸다.
			2. caller: 자신을 호출한 함수를 나타낸다. 호출한 함수가 없으면 null
			
			
			