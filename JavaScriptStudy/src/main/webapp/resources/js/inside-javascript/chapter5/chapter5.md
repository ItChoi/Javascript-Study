### 인사이드 자바스크립트 5장 - 실행 컨텍스트와 클로저
순서
1. 실행 컨텍스트 
2. 활성 객체와 변수 객체
3. 스코프 체인
4. 클로저


- 1.1 실행 컨텍스트
    - JS가 실행될 때 생성되는 하나의 실행 단위
    - ECMAScript에서는 "실행 가능한 코드를 형성화하고 구분하는 추상적인 개념"으로 설명한다.
    - ECMAScript에서는 실행 컨텍스트 형성되는 경우를 세 가지로 실행했을 경우로 규정
      - 전역 코드
      - eval()함수로 실행되는 코드
      - 함수 안의 코드
      
    - 스택 안에 하나씩 쌓이고, 맨 위가 현재 실행되는 컨텍스트다.

- 1.2 실행 컨텍스트 생성 과정
    - ex)
      - func1(param1, param2) 선언
      - func1 내부 var a = 1, b = 2;
      - func1 내부 func2 선언 - func2는 return a+b
      - func1 return param1 + param2 + func2
    - 설명
      - 1. 실행 컨텍스트 생성 시 JS 엔진은 컨텍스트 실행에 필요한 정보(매개변수, 변수, 객체)를 담을 활성객체를 생성한다.

      - 2. arguments 객체 생성: param1, param2를 담고 있다.
      - 3. 스코프 정보 생성: 현재 컨텍스트의 유효 범위, 스코프 정보는 현재 실행 중인 실행컨텍스트 안에서 연결리스트와 유사한 형식으로 만들어지며, 이 리스트를 스코프 체인이라고 한다. 스코프 체인을 통해 현재 컨텍스트 변수 뿐 아니라 상위 컨텍스트 변수에도 접근이 가능하다. // [[scope]]로 참조 된다.
      
      - 4. 변수 생성: 활성 객체 === 변수 객체, 활성 객체 안에서 호출된 인자는 각각의 프로퍼티로 만들어지고 값이 할당된다. 주의할 점은 변수나 내부 함수는 메모리에 생성만 하고, 초기화는 변수나 함수가 실행되기 전까지 되지 않는다. 그래서 a와 b에는 undefined가 할당된다. 실행은 변수 객체 생성이 다 이루어지고 시작한다.
      - 5. this 바인딩: this가 참조하는 객체가 없다면 전역 객체 참조
      - 6. 코드 실행: 변수 초기화, 연산, 함수 실행을 한다.
      
- 3. 스코프 체인
    - JS는 함수 내의 for(), if() 같은 구문은 유효 범위가 없다. 함수만 유효 범위의 단위가 된다. [[scope]] 프로퍼티로 함수 객체 내에서 연결 리스트 형식으로 관리되는데, 이를 스코프 체인이라 한다.
    - JS에 변수만을 선언하면 전역 실행 컨텍스트가 생성되고 변수 객체가 생성된다. 이 전역 객체의 [[scope]]는 자기 자신만을 가진다. 그리고 만약 변수와 함수를 선언한다면, 앞에 얘기한 전역 실행 컨텍스트 및 변수 객체가 생성되고, 함수에 대한 실행 컨텍스트 및 활성 객체가 생성된다. 이 [[scope]]는 전역 객체의 [[scope]]를 복사하여 가지고 온 후 현재 생성된 함수의 변수 객체를 맨 앞에 추가한다. ex) 0 전역객체, 1 함수의 변수 객체
    - 스코프 체인 = 현재 실행 컨텍스트의 변수 객체 + 상위 컨텍스트의 스코프 체인
    - 스코프 체인을 통해 식별자를 인식하게 되는데, 첫 번째 변수 객체부터 시작하여 대응되는 프로퍼티가 있는지 확인한다. 참고로 this는 식별자가 아닌 키워드로 분류되므로 스코프 체인의 참조 없이 접근 가능하다.
    - JS는 with 키워드를 통해 스코프 체인을 사용자 임의로 수정할 수 있다.
    
- 4. 클로저
    - ex) <br/>
    function outerFunc() {  
        var x = 10; // 자유 변수: 
        var innerFunc = function() { console.log(x); }  
        return innerFunc;  
    }  
    var inner = outerFunc();  
    inner(); // 10
    <br/>
      
    - 해설  
    먼저 전역 실행 컨텍스트가 생성되어 활성 객체가 생성되고, outerFunc 함수 호출로 인한 실행 컨텍스트 및 활성 객체가 생성된다. 그리고 innerFunc도 마찬가지로 생성되는데, outerFunc의 실행 컨텍스트가 끝나도 여전히 innerFunc 실행 컨텍스트에서는 scope를 통해 outerFunc의 활성 객체를 참조할 수 있다. 이것이 바로 클로저~ 즉, 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수를 클로저라고 한다. 예제에서는 innerFunc이 클로저다.  
<br/><br/>
    
    - 클로저의 활용
      - 클로저는 성능, 자원적인 면에서 약간 손해를 볼 수 있으니 막무가내 사용 자제  
       
#### 함수의 캡슐화
- 전역 변수로 설정하면 여러 함수에서의 접근이 가능하여 값이 의도와는 다르게 변경될 수 있다. 이러한 충돌 가능성을 대비하여 클로저를 활용할 수 있다.
- 전역 실행 컨텍스트, 실행 컨텍스트의 스코프를 이용하여 즉시 실행 함수에 변수가 할당되어 사용 가능하도록 한다. 스코프에는 [0]전역객체 -> [1]익명함수1 변수객체 -> [2]익명함수2 변수객체
```javascript
var getCompletedStr = (function() {
	var buffAr = [
		'I am ',
		'',
		'. I live in ',
		'',
		'. I\'am ',
		'',
		' years old.',
	];
	
	return (function(name, city, age) {
		buffAr[1] = name;
		buffAr[3] = city;
		buffAr[5] = age;
		
		return buffAr.join('');
	});
})();

var str = getCompletedStr('zzoon', 'seoul', 16);
console.log(str);
```

#### setTimeout()에 지정되는 함수의 사용자 정의
- setTimeout 함수는 웹 브라우저에서 제공하는 함수이다.
- 첫 번째 인자는 함수 실행의 스케줄링, 함수 실행하기 위한 객체를 넣으면 되고
- 두 번째 인자는 밀리 초 단위 숫자만큼 시간 간격으로 해당 함수를 호출한다.

#### 클로저 활용 시 주의사항
- 클로저는 강력한 기능이지만, 너무 남발해서 사용하면 비효율!
    1. 클로저의 프로퍼티 값이 여러 번 호출 하여 값이 변경될 수 있음을 주의
    2. 하나의 클로저가 여러 개의 함수 객체의 스코프 체인에 들어갈 수 있다.
    3. 루프 안에서 클로저 활용시 주의
    

    
    